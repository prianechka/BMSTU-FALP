\chapter*{Практическое задание}

\section*{Задание 1}
Каковы результаты вычисления следующих выражений?

\FloatBarrier
\begin{lstinputlisting}[style={lsp}]{src/1.lsp}
\end{lstinputlisting}
\FloatBarrier

\section*{Задание 2}
Каковы результаты вычисления следующих выражений, и почему?

\FloatBarrier
\begin{lstinputlisting}[style={lsp}]{src/2.lsp}
\end{lstinputlisting}
\FloatBarrier

\section*{Задание 3}
Написать, по крайней мере, два варианта функции, которая возвращает последний элемент
своего списка-аргумента.

\FloatBarrier
\begin{lstinputlisting}[style={lsp}]{src/3.lsp}
\end{lstinputlisting}
\FloatBarrier

\clearpage

\section*{Задание 4}
Написать, по крайней мере, два варианта функции, которая возвращает свой список-аргумент без последнего элемента.

\FloatBarrier
\begin{lstinputlisting}[style={lsp}]{src/4.lsp}
\end{lstinputlisting}
\FloatBarrier

\section*{Задание 5}
Написать простой вариант игры в кости, в котором бросаются две правильные кости. Если
сумма выпавших очков равна 7 или 11 -- выигрыш, если выпало (1,1) или (6,6) --- игрок право
снова бросить кости, во всех остальных случаях ход переходит ко второму игроку, но
запоминается сумма выпавших очков. Если второй игрок не выигрывает абсолютно, то
выигрывает тот игрок, у которого больше очков. Результат игры и значения выпавших костей
выводить на экран с помощью функции print.

\FloatBarrier
\begin{lstinputlisting}[style={lsp}]{src/5.lsp}
\end{lstinputlisting}
\FloatBarrier

\section*{Контрольные вопросы}

\subsection*{1. Синтаксическая форма и хранение программы в памяти}

В \texttt{LISP} формы представления программы и обрабатываемых ею данных одинаковы и представляются в виде \texttt{S-выражений}. 
Поэтому программы могут обрабатывать и преобразовывать другие программы и даже самих себя. 
В процессе трансляции можно введенное и сформированное в результате вычислений выражение данных проинтерпретировать в качестве программы и непосредственно выполнить. 
Так как программа представляет собой S-выражение, в памяти она представлена либо как атом (5 указателей; форма представления атома в памяти), либо списковой ячейкой (бинарный узел; 2 указателя).

\subsection*{2. Трактовка элементов списка}

Первый аргумент списка, который поступает на вход интерпретатору, трактуется как имя функции, остальные -- как аргументы этой функции.

\subsection*{3. Порядок реализации программы}

Программа в языке \texttt{LISP} представляется \texttt{S-выражением}, которое передается интерпретатору -- функции \texttt{eval}, которая выводит последний, полученный после обработки S-выражения, результат.
Работа функции \texttt{eval} представлена на картинке ниже.

\subsection*{4. Способы определения функций}

С помощью макро определения \texttt{defun} или с использованием Лямбда-нотации (функция без имени).